"use strict";
const command_1 = require("@oclif/command");
const fs_1 = require("fs");
const path_1 = require("path");
const glob = require("glob");
const isGlob = require("is-glob");
const fileReducer = (acc, cur) => {
    if (isGlob(cur)) {
        acc = [...acc, ...glob.sync(cur).map((item) => path_1.resolve(item))];
    }
    else {
        acc = [...acc, path_1.resolve(cur)];
    }
    return acc;
};
const fileWriterReducer = (acc, cur) => acc + fs_1.readFileSync(cur, "utf-8");
class PrismaMergeSchema extends command_1.Command {
    constructor() {
        super(...arguments);
        this.applyExtensions = (str, extendsDecorations = []) => {
            extendsDecorations.forEach((extension) => {
                const [_, extendsTo, extendsWith] = extension.match(/extends ([^ ]* [^ ]*) \{([^}]*)/);
                const extendsToRegExp = new RegExp(`${extendsTo}[^}]*}`);
                const extendsToNext = str
                    .match(extendsToRegExp)[0]
                    .replace("}", extendsWith + "}");
                str = str.replace(extendsToRegExp, extendsToNext);
            });
            return str;
        };
        this.applyRemovals = (str, removeDecorations = []) => {
            removeDecorations.forEach((extension) => {
                let [_, modelToRemoveFrom, itemsToRemove] = extension.match(/remove ([^ ]* [^ ]*) \{([^}]*)/);
                itemsToRemove = itemsToRemove
                    .split("\n")
                    .filter((i) => i !== "")
                    .map((i) => i.trim());
                // Find the line inside the appropriate model
                const splitStr = str.split("\n");
                // Create a trimmed, cloned version of the schema to compare against, and remove items from the
                // array based on this index
                [
                    ...splitStr.map((i) => {
                        i = i.replace(/^\s+/, "");
                        if (!i.startsWith("model")) {
                            i = i.substring(0, i.indexOf(" "));
                        }
                        return i;
                    }),
                ].forEach((line, idx, thisArray) => {
                    if (line.trim().startsWith(modelToRemoveFrom)) {
                        for (const itemToRemove of itemsToRemove) {
                            let lineToRemove = thisArray.indexOf(itemToRemove, idx);
                            if (lineToRemove > -1) {
                                delete splitStr[lineToRemove];
                            }
                        }
                    }
                });
                str = splitStr.filter((item) => item && item !== "").join("\n");
            });
            return str;
        };
        this.applyReplacements = (str, replaceDecorations = []) => {
            replaceDecorations.forEach((extension) => {
                let [_, modelToReplaceIn, replacements] = extension.match(/replaces ([^ ]* [^ ]*) \{([^}]*)/);
                replacements = replacements
                    .split("\n")
                    .filter((i) => i !== "")
                    .map((i) => {
                    const content = i.trim();
                    return {
                        linePrefix: content.substring(0, content.indexOf(" ")),
                        content,
                    };
                });
                // Find the line inside the appropriate model
                const splitStr = str.split("\n");
                const leftTrimmed = [
                    ...splitStr.map((i) => {
                        i = i.replace(/^\s+/, "");
                        if (!i.startsWith("model")) {
                            i = i.substring(0, i.indexOf(" "));
                        }
                        return i;
                    }),
                ];
                // find the index of the model to replace in
                const modelIndex = leftTrimmed.findIndex((line) => line.startsWith(modelToReplaceIn));
                if (modelIndex > -1) {
                    for (const replacement of replacements) {
                        const lineIndex = leftTrimmed.indexOf(replacement.linePrefix, modelIndex);
                        if (lineIndex > -1) {
                            splitStr[lineIndex] = replacement.content;
                        }
                    }
                }
                str = splitStr.join("\n");
            });
            return str;
        };
        this.prismaSchemaMerge = (schema) => {
            const removeDecorators = schema
                .replace(/extends [^{]*[^}]*\}/gs, "")
                .replace(/replaces [^{]*[^}]*\}/gs, "")
                .replace(/remove [^{]*[^}]*\}/gs, "");
            const extensions = schema.match(/extends [^{]*[^}]*\}/gs) || [];
            const removals = schema.match(/remove [^{]*[^}]*\}/gs) || [];
            const replacements = schema.match(/replaces [^{]*[^}]*\}/gs) || [];
            let merged = removeDecorators;
            // FIXME: Conditionally apply these based on flags
            merged = this.applyExtensions(merged, extensions);
            merged = this.applyRemovals(merged, removals);
            merged = this.applyReplacements(merged, replacements);
            return merged;
        };
    }
    async run() {
        const { args, flags } = this.parse(PrismaMergeSchema);
        let decoratorFiles = [];
        let decoratorFileAsString = "";
        const datasourceFiles = flags.datasource.reduce(fileReducer, []);
        if (!datasourceFiles.length) {
            this.error("No datasource files found");
        }
        if (flags.decorators) {
            decoratorFiles = flags.decorators.reduce(fileReducer, []);
            decoratorFileAsString = decoratorFiles.reduce(fileWriterReducer, "");
        }
        const datasourceFileAsString = datasourceFiles.reduce(fileWriterReducer, "");
        const outputPath = path_1.resolve(flags.outputFile || "./prisma/schema.prisma");
        const outputDir = path_1.dirname(outputPath);
        if (!fs_1.existsSync(outputDir)) {
            this.error(`Directory ${outputDir} does not exist. If you don't specify --output-file the CLI defaults to ./prisma/schema.prisma`);
        }
        const schemaRaw = datasourceFileAsString.toString() + decoratorFileAsString.toString();
        const schemaMerged = "// This file was generated by prisma-merge-schema (https://www.npmjs.com/package/prisma-merge-schema)\n" +
            this.prismaSchemaMerge(schemaRaw);
        fs_1.writeFileSync(outputPath, schemaMerged, "utf-8");
        this.log(`File ${outputPath} created.`);
    }
}
PrismaMergeSchema.description = "Merges a prisma datasource schema with a postfix schema";
PrismaMergeSchema.flags = {
    // add --version flag to show CLI version
    version: command_1.flags.version({ char: "v" }),
    help: command_1.flags.help({ char: "h" }),
    datasource: command_1.flags.string({ char: "d", required: true, multiple: true }),
    decorators: command_1.flags.string({ char: "e", multiple: true }),
    outputFile: command_1.flags.string({ char: "o" }),
};
module.exports = PrismaMergeSchema;
